/**
 * This file is part of the nestk library.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Nicolas Burrus <nicolas.burrus@uc3m.es>, (C) 2010
 */

#include "freenect_grabber.h"
extern "C" {
#include <libfreenect.h>
}
#include <ntk/utils/opencv_utils.h>
#include <ntk/utils/time.h>
#include <ntk/camera/rgbd_processor.h>
#include <ntk/camera/rgbd_image.h>

// FIXME: Factor this out.
#ifdef _WIN32
#   define NOMINMAX
#   define VC_EXTRALEAN
#   define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#   undef WIN32_LEAN_AND_MEAN
#   undef VC_EXTRALEAN
#   undef NOMINMAX
#endif

using namespace cv;

namespace ntk
{

static void kinect_depth_db(freenect_device *dev, void *v_depth, uint32_t timestamp)
{
    FreenectGrabber* grabber = reinterpret_cast<FreenectGrabber*>(freenect_get_user(dev));
    uint16_t *depth = reinterpret_cast<uint16_t*>(v_depth);
    grabber->depthCallBack(depth, FREENECT_FRAME_W, FREENECT_FRAME_H);
}

static void kinect_video_db(freenect_device *dev, void *rgb, uint32_t timestamp)
{
    FreenectGrabber* grabber = reinterpret_cast<FreenectGrabber*>(freenect_get_user(dev));
    if (grabber->irModeEnabled()) { // ir mode
		uint8_t *ir_cast = reinterpret_cast<uint8_t*>(rgb);
		grabber->irCallBack(ir_cast, FREENECT_FRAME_W, FREENECT_FRAME_H);
	} else { // rgb mode
	    uint8_t *rgb_cast = reinterpret_cast<uint8_t*>(rgb);
	    grabber->rgbCallBack(rgb_cast, FREENECT_FRAME_W, FREENECT_FRAME_H);
	}
}

void FreenectGrabber :: irCallBack(uint8_t *buf, int width, int height)
{
    ntk_assert(width == m_current_image.rawIntensity().cols, "Bad width");
    ntk_assert(height == m_current_image.rawIntensity().rows, "Bad height");
    float* intensity_buf = m_current_image.rawIntensityRef().ptr<float>();
    for (int i = 0; i < width*height; ++i)
        *intensity_buf++ = *buf++;
    m_rgb_transmitted = false;
}

void FreenectGrabber :: depthCallBack(uint16_t *buf, int width, int height)
{
    ntk_assert(width == m_current_image.rawDepth().cols, "Bad width");
    ntk_assert(height == m_current_image.rawDepth().rows, "Bad height");
    float* depth_buf = m_current_image.rawDepthRef().ptr<float>();
    for (int i = 0; i < width*height; ++i)
        *depth_buf++ = *buf++;
    m_depth_transmitted = false;
}

void FreenectGrabber :: rgbCallBack(uint8_t *buf, int width, int height)
{
    ntk_assert(width == m_current_image.rawRgb().cols, "Bad width");
    ntk_assert(height == m_current_image.rawRgb().rows, "Bad height");
    std::copy(buf, buf+3*width*height, (uint8_t*)m_current_image.rawRgbRef().ptr());
    cvtColor(m_current_image.rawRgb(), m_current_image.rawRgbRef(), CV_RGB2BGR);
    m_rgb_transmitted = false;
}

void FreenectGrabber :: setTiltAngle(int angle)
{
    if (!isConnected()) return;
    freenect_set_tilt_degs(f_dev, angle);
}

void FreenectGrabber :: setDualRgbIR(bool enable)
{
    m_dual_ir_rgb = enable;
}

void FreenectGrabber :: setIRMode(bool ir)
{
    if (!isConnected()) return;

    QWriteLocker locker(&m_lock);
    m_ir_mode = ir;
    freenect_stop_video(f_dev);
    if (!m_ir_mode)
        freenect_set_video_format(f_dev, FREENECT_VIDEO_RGB);
    else
        freenect_set_video_format(f_dev, FREENECT_VIDEO_IR_8BIT);
    freenect_start_video(f_dev);
}

void FreenectGrabber :: startKinect()
{
    freenect_start_depth(f_dev);
    setIRMode(m_ir_mode);
}

bool FreenectGrabber :: connectToDevice()
{
    if (freenect_init(&f_ctx, NULL) < 0)
    {
        ntk_dbg(0) << "freenect_init() failed";
        return false;
    }
    ntk_dbg(0) << "Connecting to device: " << m_device_id;
    if (freenect_open_device(f_ctx, &f_dev, m_device_id) < 0)
    {
        ntk_dbg(0) << "freenect_open_device() failed";
        return false;
    }

    freenect_set_user(f_dev, this);

    freenect_set_depth_callback(f_dev, kinect_depth_db);
    freenect_set_video_callback(f_dev, kinect_video_db);

    this->setIRMode(m_ir_mode);
    m_connected = true;
    return true;
}

bool FreenectGrabber :: disconnectFromDevice()
{
    // Exit requested.
    m_connected = false;
    freenect_close_device(f_dev);
    freenect_shutdown(f_ctx);
    return true;
}

void FreenectGrabber :: run()
{
    m_should_exit = false;
    m_current_image.setCalibration(m_calib_data);
    m_rgbd_image.setCalibration(m_calib_data);

    m_rgbd_image.rawRgbRef() = Mat3b(FREENECT_FRAME_H, FREENECT_FRAME_W);
    m_rgbd_image.rawDepthRef() = Mat1f(FREENECT_FRAME_H, FREENECT_FRAME_W);
    m_rgbd_image.rawIntensityRef() = Mat1f(FREENECT_FRAME_H, FREENECT_FRAME_W);

    m_current_image.rawRgbRef() = Mat3b(FREENECT_FRAME_H, FREENECT_FRAME_W);
    m_current_image.rawDepthRef() = Mat1f(FREENECT_FRAME_H, FREENECT_FRAME_W);
    m_current_image.rawIntensityRef() = Mat1f(FREENECT_FRAME_H, FREENECT_FRAME_W);

    startKinect();
    int64 last_grab_time = 0;

    while (!m_should_exit)
    {
        waitForNewEvent();
        while (m_depth_transmitted || m_rgb_transmitted)
            freenect_process_events(f_ctx);

        // m_current_image.rawDepth().copyTo(m_current_image.rawAmplitudeRef());
        // m_current_image.rawDepth().copyTo(m_current_image.rawIntensityRef());

        {
            int64 grab_time = ntk::Time::getMillisecondCounter();
            ntk_dbg_print(grab_time - last_grab_time, 2);
            last_grab_time = grab_time;
            QWriteLocker locker(&m_lock);
            // FIXME: ugly hack to handle the possible time
            // gaps between rgb and IR frames in dual mode.
            if (m_dual_ir_rgb)
                m_current_image.copyTo(m_rgbd_image);
            else
                m_current_image.swap(m_rgbd_image);
            m_rgb_transmitted = true;
            m_depth_transmitted = true;
        }

        if (m_dual_ir_rgb)
            setIRMode(!m_ir_mode);
        advertiseNewFrame();
#ifdef _WIN32
        // FIXME: this is to avoid GUI freezes with libfreenect on Windows.
        // See http://groups.google.com/group/openkinect/t/b1d828d108e9e69
        Sleep(1);
#endif
    }
}

} // ntk
